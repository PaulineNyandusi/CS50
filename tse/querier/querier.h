/*
* querier.h - header file for CS50 'querier' module
*
* The Querier module is responsible for processing queries against an index
* generated by the Crawler module. It employs logical 'AND' and 'OR' operations
* to evaluate queries and returns a set of documents that match the query.
* It also includes functions for handling the intersection and union of counters,
* which are used to represent query results.
*
*The querier.c program serves as a query engine that interacts with an inverted
*index to evaluate and process search queries. It returns a list of documents that
*match the query, ranked by relevance.




* Pauline Nyandusi, October 30th 2023
*/


#ifndef __QUERIER_H
#define __QUERIER_H




#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>
#include "../libcs50/webpage.h"
#include "../libcs50/file.h"
#include "../libcs50/counters.h"
#include "../libcs50/bag.h"
#include "../libcs50/hashtable.h"
#include "../common/pagedir.h"
#include "../common/word.h"
#include "../common/index.h"
#include "../libcs50/mem.h"




/**************** querryProcessor ****************/
/* Process a query and return a counter of results.
*
* Caller provides:
* - valid index_t pointer (index)
* - valid pointer to an array of words (arrayofWords)
* - integer count of words in the array (count)
* We guarantee:
* - a counters_t pointer containing the results of the query
* Caller is responsible for:
* - ensuring that all pointers and counts are valid
* Note:
* - The function uses 'AND' and 'OR' logic to process the query
*/
counters_t *querryProcessor(index_t *index, char **arrayOfWords, int wordNumbers);


/**************** countersMerge ****************/
/* Merge an intersected counter into a union counter.
*
* Caller provides:
* - valid pointers to two counters_t pointers: andIntersectSequence and orUnionSequence.
* We guarantee:
* - the orUnionSequence counter will be updated to include the union with andIntersectSequence.
* - the andIntersectSequence counter will be deleted and set to NULL.
* Caller is responsible for:
* - ensuring that the pointers to counters_t pointers are valid.
* Note:
* - The function relies on countersUnion to perform the union operation.
* - Memory checks are performed for the counters at the beginning.
*/
void countersMerge(counters_t **andIntersectSequence, counters_t **orUnionSequence);

/**************** countersUnion ****************/
/* Union two counters and update the first counter based on the union.
*
* Caller provides:
* - valid pointers to two counters_t types: first and second.
* We guarantee:
* - the first counter will be updated to reflect the union with the second counter.
* Caller is responsible for:
* - ensuring that both counter pointers are valid.
* Note:
* - The function relies on a helper function, findUnionHelper, to perform the union.
* - Memory assertion checks are performed for both counters at the beginning.
*/
void FindCountersUnion(counters_t *one, counters_t *two);


/**************** findUnionHelper ****************/
/* Update a counter based on the union with another counter.
*
* Caller provides:
* - valid pointer to a counters_t structure, representing one counter.
* - integer key representing a key in the counter.
* - integer occurrenceCount representing the value for that key in another counter.
* We guarantee:
* - the value for the specified key in the given counter will be updated to be the sum of its own value and occurrenceCount.
* Caller is responsible for:
* - ensuring that the counters_t pointer is valid.
* - ensuring that the key exists in the counter for a meaningful union operation.
* Note:
* - This is a helper function that is typically invoked in the context of an iteration operation over another counter.
* - The function performs an in-place update of the values in the given counter.
*/
void findCountersUnionHelper(void *arg, const int key, const int count);


/**************** countersIntersect ****************/
/* Intersect two counters and update the first counter with the intersection.
*
* Caller provides:
* - valid pointers to two counters: first and second.
* We guarantee:
* - the first counter will be updated to represent the intersection of both counters.
* Specifically, for each key in the first counter, its value will be updated to the minimum
* of its own value and the value of the same key in the second counter.
* Caller is responsible for:
* - ensuring that both counter pointers are valid.
* - ensuring that both counters have the same keys for a meaningful intersection.
* Note:
* - This function relies on a helper function, findIntersectionHelper, to perform the intersection.
* - The function performs memory assertion checks for both counters before proceeding.
*/
void FindCountersIntersect(counters_t *one, counters_t *two);


/**************** findIntersectionHelper ****************/
/* Update the first counter based on the intersection with the second counter.
*
* Caller provides:
* - valid pointer to a struct doubleCounters, containing two counters.
* - integer key representing the key in the counter.
* - integer occurrenceCount representing the value for that key in the first counter.
* We guarantee:
* - the value for the specified key in the first counter will be updated to the minimum of occurrenceCount and its corresponding value in the second counter.
* Caller is responsible for:
* - ensuring that the struct doubleCounters pointer is valid.
* - ensuring that the key exists in both counters.
* Note:
* - This is a helper function that is typically invoked in the context of an iteration operation over a data structure.
*/
void findCountersIntersectHelper(void *arg, const int key, const int count);


/**************** splitIntoWords ****************/
/* Split a query input into an array of words.
*
* Caller provides:
* - a valid pointer to an array of strings (arrayofWords) that will hold the words.
* - a valid pointer to a string containing the query input (queryInput).
* We guarantee:
* - an integer return indicating the number of words split, or -1 if invalid structure is found.
* Caller is responsible for:
* - ensuring both pointers are valid.
* Note:
* - The function normalizes each word before storing it in the array.
*/

int splitIntoWords(char **arrayOfWords, char *queryInput);


/**************** isAnd ****************/
/* Determine if a given word is 'and'.
*
* Caller provides:
* - valid pointer to a string containing the word to check.
* We guarantee:
* - a boolean return indicating whether the word is 'and'.
* Caller is responsible for:
* - ensuring that the pointer to the string is valid, or understanding that NULL will return false.
* Note:
* - The function checks for NULL pointers and will return false in such cases.
*/
bool isAnd(char *word);



/**************** validateStructure ****************/
/* Validate the structure of an array of strings containing query operators and operands.
*
* Caller provides:
* - valid pointer to an array of strings and the count of those strings.
* We guarantee:
* - a boolean return indicating whether the structure of the query is valid.
* Caller is responsible for:
* - ensuring that the array and count are valid.
* Note:
* - The function performs checks for invalid placement of 'AND' and 'OR' in the query array.
*/
bool validateStructure(char **arrayOfWords, int wordNumbers);


/**************** isOr ****************/
/* Determine if a given word is 'or'.
*
* Caller provides:
* - valid pointer to a string containing the word to check.
* We guarantee:
* - a boolean return indicating whether the word is 'or'.
* Caller is responsible for:
* - ensuring that the pointer to the string is valid, or understanding that NULL will return false.
* Note:
* - The function checks for NULL pointers and will return false in such cases.
*/
bool isOr(char *word);


/**************** is_and_or ****************/
/* Determine if a given word is 'AND' or 'OR'.
*
* Caller provides:
* - valid pointer to a string containing the word to check.
* We guarantee:
* - a boolean return indicating whether the word is 'AND' or 'OR'.
* Caller is responsible for:
* - ensuring that the pointer to the string is valid, or understanding that NULL will return false.
* Note:
* - The function checks for NULL pointers and will return false in such cases.
*/
bool is_and_or(char *word);


/************** print_results() ***************/
/**
 * The print_results function ranks and prints documents according to their computed scores.
 * 
 * Caller provides:
 * - A valid pointer to a counters_t structure, which holds the scores for each document.
 * - A valid pointer to a string containing the directory path where the pages are stored.
 *
 * We guarantee:
 * - To rank the documents by their scores and print them in descending order.
 * - To free dynamically allocated memory used within the function.
 * 
 * Caller is responsible for:
 * - Ensuring that the pointers to counters_t and the string are valid, or understanding that NULL will yield no output.
 * 
 * Note:
 * - The function validates the existence of a counters_t set; if NULL, it prints a message indicating no matches.
 * - The function makes use of helper functions like counters_iterate(), getLargest(), and printerResultsHelper().
 * - Memory for a DocumentScore_t structure is dynamically allocated within the function and freed before exit.
 */
void print_result(counters_t *countersone, char *pageDirectory);


#endif // __QUERIER_H



